---
title: "Dice Enterprise"
author: "Giulio Morina"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width=7, fig.height=4,
  cache=TRUE
)
require("DiceEnterprise")
set.seed(17)
```


## Introduction

The `DiceEnterprise` package provides an automatic way to construct a Bernoulli Factory/Dice Enterprise algorithm for rational functions between simplices $f: \Delta^m \rightarrow \Delta^v$. That is, given an $m$-sided die, a $v$ sided-one is produced where the probability of each of the $v$ faces is a rational function. More formally, $f(\boldsymbol{p})$ is of the following form:
$$
f(\boldsymbol{p}) = f(p_1,\ldots,p_m) = \frac{1}{C(\boldsymbol{p})}\left(G_1(\boldsymbol{p},\ldots,G_v(\boldsymbol{p})\right)
$$
where each $G_i(\boldsymbol{p})$ and $C(\boldsymbol{p})$ are polynomials with real coefficients. 

The Bernoulli Factory is a special case of this setting. In particular, assume a $p$-coin is given. Then, the package can construct an $f(p)$-coin where $f(p)$ is a rational function.

## Bernoulli Factory

The user can define a function that tosses a $p$-coin and returns $1$ with probability $p$ and 2 with probability $1-p$ (notice that **it should not return 1 or 0**). The function should have as input the number `n` of required tosses.  For instance the following function tosses a $\frac{3}{4}$-coin
```{r toss_coin}
toss_coin <- function(n) {
  sample(1:2, size = n, replace = TRUE, prob = c(3/4,1/4))
}
```

Then, the user needs to define the rational function $f(p)$ in a specific format. For instance, assume that 
$$
f(p) = \frac{\sqrt{2}p^3}{(\sqrt{2}-5)p^3+11p^2-9p+3}
$$
so that 
$$
1-f(p) = \frac{-5p^3+11p^2-9p+3}{(\sqrt{2}-5)p^3+11p^2-9p+3}
$$
Then, the user needs to specify the numerators of $f(p)$ and $1-f(p)$ in the following format:
```{r bf_poly}
f_1 <- list(coeff = c(sqrt(2)), power = c(3)) #f(p)
f_2 <- list(coeff = c(-5,11,-9,3), power = c(3,2,1,0)) #1-f(p)
```
Notice that the polynomials are represented as a list: the first element is a vector of coefficients and the second element is a vector describing the powers of $p$. Finally, the user can construct a new Bernoulli Factory running the following code:
```{r bf_construction}
bf <- BernoulliFactory$new(f_1 = f_1, f_2 = f_2) #f_1 = f(p), f_2 = 1-f(p)
```
and toss an $f(p)$-coin by running
```{r bf_toss}
fp_tosses <- bf$sample(n = 10, roll.fun = toss_coin) #Produces 10 tosses of the f(p)-coin
print(fp_tosses)
```

### Diagnosis and extra options

Printing the `BernoulliFactory` object gives information on the dimension of the generated fine and connected ladder. When a `BernoulliFactory` object is created, if the option `verbose` is set equal to `TRUE`, then more information are printed on the different steps of the construction. 

```{r bf_diagnosis}
bf <- BernoulliFactory$new(f_1 = f_1, f_2 = f_2, verbose = TRUE)
print(bf)
```
The method `evaluate` allows to evaluate the value of $f(p)$ for a given $p$. 
```{r bf_evaluate}
print(bf$evaluate(3/4))
```
Also the method `sample` allows to set the option `verbose = TRUE`. In this case the average number of tosses required by the CFTP is printed. The same method allows to specify the number of cores used (default 1).
```{r bf_toss_2}
fp_tosses <- bf$sample(n = 1000, roll.fun = toss_coin, num_cores = 2, verbose = TRUE) #Produces 1000 tosses of the f(p)-coin, using 2 cores
print(table(fp_tosses)/1000) #Empirical probabilities. Notice that the theoretical ones are given by print(bf$evaluate(3/4))
```
The function `plotConfidenceInterval` allows to print the estimated probabilities with 95% confidence interval. The stars indicate the true theoretical values.
```{r bf_plot}
plotConfidenceInterval(fp_tosses,print(bf$evaluate(3/4)))
```

Notice that the package supports only functions defined from $(0,1)$ to $[0,1]$ and not from subset $S \subset (0,1)$. For instance, if the user defines a Bernoulli Factory for the function $f(p) = 2p$, an error is returned:
```{r bf_error, error=TRUE}
bf_amp <- BernoulliFactory$new(f_1 = list(2,1), f_2 = list(c(1,-2),c(0,1)))
```

## Dice Enterprise
The procedure is similar to the previous. Assume that the given function $f(\boldsymbol{p}): \Delta^m \rightarrow \Delta^v$ is 
$$
f(p_1,p_2,p_3) \propto (p_1p_2^2+\sqrt{2}p_2^2p_3^2, 4p_1^4p_2^7+1/2+3p_1p_2^2p_3^3,7p_1p_2^3p_3^4+2p_3^2)
$$
The user needs to define a list that specify the polymomial $f(\boldsymbol{p})$. Each element corresponds to $f_i(\boldsymbol{p})$ and each of this function is determined by a list itself containing two elements:
1. A vector of the coefficients (as in the Bernoulli Factory case)
2. A matrix or a vector of string defining the power of the variables. If a matrix is given, it has to have $m$ columns and each row defines the power of $p_1,p_2,\ldots,p_m$ respectively. For instance $p_1p_2^2+\sqrt{2}p_2^2p_3^2$ is translated into the matrix 
$$
\begin{bmatrix}
1 & 2 & 0 \\
0 & 2 & 2
\end{bmatrix}
$$
Alternatively, the same powers can be defined via a vector of strings. The powers of the previous polynomial $p_1p_2^2+\sqrt{2}p_2^2p_3^2$ can also be defined as `c("120","022")`. Notice that this method works **only** if there are no powers greater than 10.

The polynomial $f(\boldsymbol{p})$ is then defined as
```{r de_polynomials}
f_dice <- list(
  list(c(1,sqrt(2)),c("120","022")),
  list(c(4,1/2,3),c("470","000","123")),
  list(c(7,2),matrix(c(1,3,4,0,0,2),byrow=TRUE,ncol=3))
)
```
To construct a Dice Enterprise with the defined polynomial the following command is run: 
```{r de_construction}
de <- DiceEnterprise$new(f_dice)
```
and an $f(\boldsymbol{p})$-die is rolled by giving a function that rolls the original $m$-sided die and using the `sample` method. 
```{r de_roll}
roll_die <- function(n) {
  sample(1:3, size = n, replace = TRUE, prob = c(1/5,1/4,1-1/5-1/4))
} #The original die has probability 1/5, 1/4, 11/20
sample_die <- de$sample(n = 10, roll.fun = roll_die)
print(sample_die)
```

### Diagnosis and extra options

Analogously as described in the Bernoulli Factory case, the method `sample` accepts as input a number for the cores to be used as well as the option to print out the average number of rolls needed. The function `plotConfidenceInterval` returns a plot of the estimates together with a 95% confidence interval.
```{r de_diagnosis}
sample_die <- de$sample(n = 1000, roll.fun = roll_die, num_cores = 2, verbose = TRUE) #Produces 1000 rolls of the f(p)-die, using 2 cores
print(table(sample_die)/1000) #Empirical probabilities. Notice that the theoretical ones are given by print(de$evaluate(c(1/5,1/4,1-1/5-1/4)))
print(de$evaluate(c(1/5,1/4,1-1/5-1/4)))
plotConfidenceInterval(sample_die,de$evaluate(c(1/5,1/4,1-1/5-1/4)))

```

## Independent coins

Assume that instead of an $m$-sided die, $m$ independent coins are given, each one with its own probability of landing heads and denoted by $p_i$. In general, $(p_1,\ldots,p_m) \not\in \Delta^m$. However, considering constructing a $m+2$-sided die with the following probabilities of rolling $\{0,1,\ldots,m\}$ (notice that the index starts now from 0 for convenience).
$$
\begin{split}
&q_0 = p_1\cdot p_2\cdot\ldots \cdot p_m \\
&q_1 = (1-p_1)\cdot p_2 \cdot \ldots \cdot p_m \\
&q_2 = p_1 \cdot (1-p_2) \cdot p_3 \cdot \ldots \cdot p_m \\
&\ldots \\
&q_m = p_1 \cdot p_2 \cdot \ldots \cdot p_{m-1} \cdot (1-p_m) \\
&q_{m+1} = 1-\sum_{i=0}^m q_i
\end{split}
$$
It is straightforward to roll such a die by tossing all the $m$ independent coins at the same time. In particular, if all the tosses result in heads, then 0 is returned. If all the tosses are heads, except for the $l$th coin, then $l$ is returned. In all other cases, $m+1$ is returned. Finally, assume that $f(\boldsymbol{p}): (0,1)^m \rightarrow \Delta^v$ is a function of the original probabilities. It is possible to construct a function $\tilde{f}(\boldsymbol{q}): \Delta^{m+2} \rightarrow \Delta^v$ by substituing:
$$
p_i = \frac{q_0}{q_0+q_i}, \qquad i \in \{1,2,\ldots,m\}
$$
Albeit not being optimal, the described method leads to a valid way to solve this class of problems.

### Example

Assume that we have access to 3 independent coins of biases $(0.4,0.7,0.55)$ and wish to sample from the distribution $f(\boldsymbol{p}) = \frac{1}{p_1+p_2+p_3}\left(p_1,p_2,p_3\right) = (8/33,14/33,1/3)$. The first step is defining a function that tosses all the three coins. Notice again that heads corresponds to 1 and tails to 2 (**not to 0**):

```{r indep_tosses}
toss.coins <- function(probs) {
  return(sapply(probs, function(p) {sample(1:2, size = 1, prob = c(p,1-p))})) #1 or 2 (not 0))
}
```

We then express the function $f(\boldsymbol{p})$ as a function of the transformed variables $\boldsymbol{q} = (q_0,\ldots,q_4)$ previously described. We get:
$$
\begin{split}
f(\boldsymbol{q}) &= \frac{1}{C(\boldsymbol{q})}\left((q_0+q_2)(q_0+q_3),(q_0+q_1)(q_0+q_3),(q_0+q_1)(q_0+q_2)\right) \\
&= \frac{1}{C(\boldsymbol{q})}\left(q_0^2+q_0q_2+q_0q_3+q_2q_3,q_0^2+q_0q_1+q_0q_3+q_1q_3,q_0^2+q_0q_1+q_0q_2+q_1q_2\right)
\end{split}
$$
where $C(\boldsymbol{q}) = 3(q_0+q_1)(q_0+q_2)(q_0+q_3)\sum_{i=1}^3 \frac{1}{q_0+q_i}$. As before, the user needs to define the three polynomials as a list of coefficients and powers:
```{r indep_poly}
f_indep_coins <- list(
  list(rep(1,4),c("20000","10100","10010","00110")),
  list(rep(1,4),c("20000","11000","10010","01010")),
  list(rep(1,4),c("20000","11000","10100","01100"))
)
```

Finally, an object of the class `CoinsEnterprise` can be created in a similar fashion as an object of the class `DiceEnterprise`.
```{r indep_creation}
ce <- CoinsEnterprise$new(f_indep_coins)
```

Getting a sample from the newly create die is done analogously as before.
```{r indep_sample}
indep_coins_probs <- c(0.4,0.7,0.55)
result <- ce$sample(n = 1000, toss.coins = toss.coins, num_cores = 2, verbose = TRUE, probs = indep_coins_probs) #the argument probs is passed to toss.coins
print(table(result)/1000) #Empirical probabilities. Notice that the theoretical ones are given by
print(indep_coins_probs/sum(indep_coins_probs))
plotConfidenceInterval(result,indep_coins_probs/sum(indep_coins_probs))

```



